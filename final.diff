diff --git a/dh/__init__.py b/dh/__init__.py
index 6d6f182..1ed729b 100644
--- a/dh/__init__.py
+++ b/dh/__init__.py
@@ -1,40 +1,63 @@
+from Crypto import Random
+
 from Crypto.Hash import SHA256
 from Crypto.Random import random
-
 from lib.helpers import read_hex
 
 # Project TODO: Is this the best choice of prime? Why? Why not? Feel free to replace!
 
-# 1536 bit safe prime for Diffie-Hellman key exchange
-# obtained from RFC 3526
+# 4096 bit safe prime for Diffie-Hellman key exchange obtained from RFC 3526
 raw_prime = """FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD1
-29024E08 8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DD
-EF9519B3 CD3A431B 302B0A6D F25F1437 4FE1356D 6D51C245
-E485B576 625E7EC6 F44C42E9 A637ED6B 0BFF5CB6 F406B7ED
-EE386BFB 5A899FA5 AE9F2411 7C4B1FE6 49286651 ECE45B3D
-C2007CB8 A163BF05 98DA4836 1C55D39A 69163FA8 FD24CF5F
-83655D23 DCA3AD96 1C62F356 208552BB 9ED52907 7096966D
-670C354E 4ABC9804 F1746C08 CA237327 FFFFFFFF FFFFFFFF"""
+      29024E08 8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DD
+      EF9519B3 CD3A431B 302B0A6D F25F1437 4FE1356D 6D51C245
+      E485B576 625E7EC6 F44C42E9 A637ED6B 0BFF5CB6 F406B7ED
+      EE386BFB 5A899FA5 AE9F2411 7C4B1FE6 49286651 ECE45B3D
+      C2007CB8 A163BF05 98DA4836 1C55D39A 69163FA8 FD24CF5F
+      83655D23 DCA3AD96 1C62F356 208552BB 9ED52907 7096966D
+      670C354E 4ABC9804 F1746C08 CA18217C 32905E46 2E36CE3B
+      E39E772C 180E8603 9B2783A2 EC07A28F B5C55DF0 6F4C52C9
+      DE2BCBF6 95581718 3995497C EA956AE5 15D22618 98FA0510
+      15728E5A 8AAAC42D AD33170D 04507A33 A85521AB DF1CBA64
+      ECFB8504 58DBEF0A 8AEA7157 5D060C7D B3970F85 A6E1E4C7
+      ABF5AE8C DB0933D7 1E8C94E0 4A25619D CEE3D226 1AD2EE6B
+      F12FFA06 D98A0864 D8760273 3EC86A64 521F2B18 177B200C
+      BBE11757 7A615D6C 770988C0 BAD946E2 08E24FA0 74E5AB31
+      43DB5BFC E0FD108E 4B82D120 A9210801 1A723C12 A787E6D7
+      88719A10 BDBA5B26 99C32718 6AF4E23C 1A946834 B6150BDA
+      2583E9CA 2AD44CE8 DBBBC2DB 04DE8EF9 2E8EFC14 1FBECAA6
+      287C5947 4E6BC05D 99B2964F A090C3A2 233BA186 515BE7ED
+      1F612970 CEE2D7AF B81BDD76 2170481C D0069127 D5B05AA9
+      93B4EA98 8D8FDDC1 86FFB7DC 90A6C08F 4DF435C9 34063199
+      FFFFFFFF FFFFFFFF"""
+
 # Convert from the value supplied in the RFC to an integer
 prime = read_hex(raw_prime)
+# q should be a prime, assuming (4096 bit safe prime - 1) / 2 is also prime
+q = (prime - 1) // 2 
+# As defined in RFC for the 4096 bit safe prime
+generator = 2
 
 # Project TODO: write the appropriate code to perform DH key exchange
-
 def create_dh_key():
     # Creates a Diffie-Hellman key
+    # Is this cryptographically secure?
+    my_private = Random.random.randrange(2, q-2)
+    dh_key = pow(generator, my_private, prime)
     # Returns (public, private)
-    a = random.randint(0, int(2**8))
-    return (a, a)
+    return (dh_key, my_private)
 
 def calculate_dh_secret(their_public, my_private):
     # Calculate the shared secret
-    shared_secret = their_public * my_private
-
+    shared_secret = pow(their_public, my_private, prime)
+    
     # Hash the value so that:
     # (a) There's no bias in the bits of the output
     #     (there may be bias if the shared secret is used raw)
     # (b) We can convert to raw bytes easily
     # (c) We could add additional information if we wanted
     # Feel free to change SHA256 to a different value if more appropriate
+    
+    # Convert to string for following command
+    shared_secret = str(shared_secret)
     shared_hash = SHA256.new(bytes(shared_secret, "ascii")).hexdigest()
     return shared_hash
diff --git a/lib/comms.py b/lib/comms.py
index 3ed42bd..18d3700 100644
--- a/lib/comms.py
+++ b/lib/comms.py
@@ -1,13 +1,17 @@
+import random
 import struct
+import Crypto.Cipher.AES as AES
 
-from Crypto.Cipher import XOR
+from Crypto import Random
+from Crypto.Hash import HMAC
+from Crypto.Hash import SHA256
 
 from dh import create_dh_key, calculate_dh_secret
 
 class StealthConn(object):
     def __init__(self, conn, client=False, server=False, verbose=False):
         self.conn = conn
-        self.cipher = None
+        self.key = None
         self.client = client
         self.server = server
         self.verbose = verbose
@@ -15,7 +19,6 @@ class StealthConn(object):
 
     def initiate_session(self):
         # Perform the initial connection handshake for agreeing on a shared secret
-
         ### TODO: Your code here!
         # This can be broken into code run just on the server or just on the client
         if self.server or self.client:
@@ -27,17 +30,84 @@ class StealthConn(object):
             # Obtain our shared secret
             shared_hash = calculate_dh_secret(their_public_key, my_private_key)
             print("Shared hash: {}".format(shared_hash))
+            # Set the key to the shared hash (should it always be the first 16?)
+            self.key = shared_hash     
+
+    def split_key(self, key):
+         # Hash the shared key and split for encrypting, seeding and hashing
+         key = SHA256.new(str(key).encode("ascii"))
+         # Encryption key
+         ekey = key.hexdigest()[:16]
+         # Random key (seed)
+         rkey = key.hexdigest()[16:40]
+         # Hash key
+         hkey = str(key.hexdigest()[40:]).encode("ascii")
+         return ekey, rkey, hkey
+         
+    def gen_random(self, key, min, max):
+        # Generate random nonce from key
+        random.seed(key)
+        r = random.randrange(min, max).to_bytes(16, byteorder='big')
+        random_num = SHA256.new(r)
+        return str(random_num.hexdigest()).encode("ascii")
+        #return random_num 
+                  
+    def hash_mac(self, key, cipher):
+         # Initialise HMAC
+         hmac = HMAC.new(key, digestmod=SHA256)
+         hmac.update(str(cipher).encode("ascii"))
+         return hmac
+                
+    # ANSI X.923 pads the message with zeroes
+    # The last byte is the number of zeroes added
+    # This should be checked on unpadding
+    def ANSI_X923_pad(self, m, pad_length):
+        # Work out how many bytes need to be added
+        required_padding = pad_length - (len(m) % pad_length)
+        # Use a bytearray so we can add to the end of m
+        b = bytearray(m)
+        # Then k-1 zero bytes, where k is the required padding
+        b.extend(bytes("\x00" * (required_padding-1), "ascii"))
+        # And finally adding the number of padding bytes added
+        b.append(required_padding)
+        return bytes(b)
 
-        # Default XOR algorithm can only take a key of length 32
-        self.cipher = XOR.new(shared_hash[:4])
+    def ANSI_X923_unpad(self, m, pad_length):
+        # The last byte should represent the number of padding bytes added
+        required_padding = m[-1]
+        # Ensure that there are required_padding - 1 zero bytes
+        if m.count(bytes([0]), -required_padding, -1) == required_padding - 1:
+            return m[:-required_padding]
+        else:
+            # Raise an exception in the case of an invalid padding
+            raise AssertionError("Padding was invalid")
 
     def send(self, data):
-        if self.cipher:
-            encrypted_data = self.cipher.encrypt(data)
+        if self.key:
+            # Split the key for use in encryption, random generator and encryption
+            ekey, rkey, hkey = self.split_key(self.key)
+
+            # Generate random nonce to be sent
+            rand_nonce = self.gen_random(rkey, 0, pow(2,128))
+
+            # Excrypt data using AES
+            iv = Random.new().read(AES.block_size)
+            cipher = AES.new(ekey, AES.MODE_CBC, iv)
+            # Pad data to be ciphered in blocks
+            data = self.ANSI_X923_pad(data, AES.block_size)           
+            ciphertext = cipher.encrypt(data)
+            
+            # Create HMAC to be sent using key and cipher
+            hmac = self.hash_mac(hkey, ciphertext)
+
+            # Send IV, encrypted data, HMAC and Nonce
+            encrypted_data = iv + ciphertext + str(hmac.hexdigest()).encode("ascii") + rand_nonce
+
             if self.verbose:
                 print("Original data: {}".format(data))
                 print("Encrypted data: {}".format(repr(encrypted_data)))
                 print("Sending packet of length {}".format(len(encrypted_data)))
+        
         else:
             encrypted_data = data
 
@@ -51,17 +121,54 @@ class StealthConn(object):
         pkt_len_packed = self.conn.recv(struct.calcsize('H'))
         unpacked_contents = struct.unpack('H', pkt_len_packed)
         pkt_len = unpacked_contents[0]
+        encrypted_data = self.conn.recv(pkt_len)    
 
-        encrypted_data = self.conn.recv(pkt_len)
-        if self.cipher:
-            data = self.cipher.decrypt(encrypted_data)
-            if self.verbose:
-                print("Receiving packet of length {}".format(pkt_len))
-                print("Encrypted data: {}".format(repr(encrypted_data)))
-                print("Original data: {}".format(data))
+        if self.key:
+            # Split the key for use in encryption, random generator and encryption
+            ekey, rkey, hkey = self.split_key(self.key)
+
+            # Check if random nonce values are correct
+            rand_nonce = self.gen_random(rkey, 0, pow(2,128))
+            if rand_nonce == encrypted_data[-64:]:
+                print("Random Nonce confirmed.")
+
+                # Recalculate HMAC using received values
+                hmac = self.hash_mac(hkey, encrypted_data[16:-128])
+
+                # Check if HMAC values are equal
+                if str(hmac.hexdigest()).encode("ascii") == encrypted_data[-128:-64]:
+                    print("HMAC confirmed.")
+                    
+                    # Obtain IV from message
+                    iv = encrypted_data[:16]
+                    # Decrypt ciphertext from message
+                    cipher = AES.new(ekey, AES.MODE_CBC, iv)
+                    data = cipher.decrypt(encrypted_data[16:-128])
+                    # Unpad data to obtain original message
+                    data = self.ANSI_X923_unpad(data, AES.block_size)
+
+                    if self.verbose:
+                        print("Receiving packet of length {}".format(pkt_len))
+                        print("Encrypted data: {}".format(repr(encrypted_data)))
+                        print("Original data: {}".format(data))
+
+                else:
+                    # HMAC received is not identical to HMAC calculated.
+                    print("HMAC Modified.")
+                    print("Received: ", encrypted_data[-128:-64])
+                    print("Calculated: ", str(hmac.hexdigest()).encode("ascii"))
+                    data = encrypted_data
+
+            else:
+                # Random nonce received is not identical to HMAC calculated.
+                print("Random Nonce not identical.")
+                print("Received: ", encrypted_data[-64:])
+                print("Calculated: ", rand_nonce)
+                data = encrypted_data
+      
         else:
             data = encrypted_data
-
+            
         return data
 
     def close(self):
-- 
2.8.1.windows.1

